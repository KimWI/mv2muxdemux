<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>MSX2 MV1/MV2 Universal Web Player</title>
    <style>
        body { background-color: #111; color: #eee; font-family: sans-serif; text-align: center; margin-top: 50px; }
        /* ğŸ’¡ í•µì‹¬: ìº”ë²„ìŠ¤ë¥¼ ê°•ì œë¡œ ëŠ˜ë ¤ë„ ë„íŠ¸(í”½ì…€)ê°€ ë­‰ê°œì§€ì§€ ì•Šê³  ì¹¼ê°™ì´ ìœ ì§€ë˜ë„ë¡ í•˜ëŠ” CSS */
        #msx-screen {
            width: 768px; /* 256 * 3 */
            height: 576px; /* 192 * 3 */
            image-rendering: pixelated;
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            background-color: #000;
        }
        .controls { margin-top: 20px; }
        button, input { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #333; color: white; border: 1px solid #555; }
        button:hover { background: #555; }
        button:disabled { background: #222; color: #666; cursor: not-allowed; }
        #status { margin-top: 15px; font-weight: bold; color: #4CAF50; }
    </style>
</head>
<body>

    <h2>MSX2 Universal Player (SCREEN 2)</h2>
    <canvas id="msx-screen" width="256" height="192"></canvas>
    
    <div class="controls">
        <input type="file" id="file-input" accept=".mv1,.mv2" />
        <button id="btn-play" disabled>â–¶ Play</button>
        <button id="btn-pause" disabled>â¸ Pause</button>
    </div>
    <div id="status">ëŒ€ê¸° ì¤‘... MV1 ë˜ëŠ” MV2 íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.</div>

<script>
class MSXMediaDemuxer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.frames = [];
        this.audioSource = null;
        this.isPlaying = false;
        this.startTime = 0;
        this.pauseTime = 0;
        this.animationId = null;
        
        // ë©”íƒ€ë°ì´í„°
        this.format = null; // 'MV1' or 'MV2'
        this.fps = 0;
        this.totalFrames = 0;
    }


    async loadFile(file) {
        document.getElementById('status').innerText = "íŒŒì¼ ë¶„ì„ ì¤‘...";
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // ğŸ’¡ ë””ë²„ê¹…ì„ ìœ„í•´ ë§¨ ì• 8ë°”ì´íŠ¸ë¥¼ Hex ë¬¸ìì—´ë¡œ ì¶”ì¶œ
        const hexDump = Array.from(data.slice(0, 8))
                             .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                             .join(' ');
        console.log("[*] File Header Hex:", hexDump);

        // ğŸ’¡ TextDecoder ëŒ€ì‹  String.fromCharCodeë¥¼ ì‚¬ìš©í•˜ì—¬ Null ë°”ì´íŠ¸ ê°„ì„­ ìµœì†Œí™”
        const sigText = String.fromCharCode(...data.slice(0, 8));

        // 1. í—¤ë” ì‹œê·¸ë‹ˆì²˜ íŒë³„ (MV1)
        if (sigText.startsWith("MMCSD_MV")) {
            this.format = "MV1";
            this.fps = 12;
            await this.parseMV1(data);
        } 
        // 2. í—¤ë” ì‹œê·¸ë‹ˆì²˜ íŒë³„ (MV2) - ê³µë°± ì—¬ë¶€ì™€ ìƒê´€ì—†ì´ 'MV2' 3ê¸€ì ìš°ì„  ê²€ì‚¬
        else if (sigText.startsWith("MV2")) {
            this.format = "MV2";
            this.fps = 15;
            await this.parseMV2(data);
        } 
        // 3. ì˜ˆì™¸ ì²˜ë¦¬ (ì‹¤ì œ Hex ê°’ í™”ë©´ì— ì¶œë ¥)
        else {
            throw new Error(`ì§€ì›í•˜ì§€ ì•ŠëŠ” í¬ë§·! í—¤ë” Hex: [ ${hexDump} ]`);
        }
        
        document.getElementById('status').innerText = `[${this.format}] íŒŒì‹± ì™„ë£Œ! (${this.fps} FPS, ${this.totalFrames} í”„ë ˆì„)`;
        document.getElementById('btn-play').disabled = false;
    }

    // ==========================================================
    // ğŸ’¡ [Format 1] MV1 íŒŒì„œ (12fps, PCM Audio, 16KB Header)
    // ==========================================================
    async parseMV1(data) {
        this.frames = [];
        let offset = 16384; // ì²« 16KBëŠ” í†µì§¸ë¡œ ê¸€ë¡œë²Œ í—¤ë”
        let pcmChunks = [];

        while (offset + 16384 <= data.length) {
            const pgt = data.slice(offset, offset + 6144);
            const ct = data.slice(offset + 6144, offset + 12288);
            const pcm = data.slice(offset + 12288, offset + 13232); // 944 bytes
            const palRaw = data.slice(offset + 13232, offset + 13264); // 32 bytes
            
            const palette = this.extractPalette(palRaw, 16);
            this.frames.push({ pgt, ct, palette });
            pcmChunks.push(pcm);
            
            offset += 16384;
        }
        
        this.totalFrames = this.frames.length;

        // 8-bit Unsigned PCM (11328Hz) -> Web Audio API Float32 ë³€í™˜
        const sampleRate = 944 * 12; // 11328 Hz
        const audioBuffer = this.audioCtx.createBuffer(1, this.totalFrames * 944, sampleRate);
        const channelData = audioBuffer.getChannelData(0);
        
        let writeOffset = 0;
        for (let i = 0; i < pcmChunks.length; i++) {
            for (let j = 0; j < 944; j++) {
                // 0~255ë¥¼ -1.0 ~ 1.0ìœ¼ë¡œ ì •ê·œí™”
                channelData[writeOffset++] = (pcmChunks[i][j] - 128) / 128.0;
            }
        }
        this.audioBuffer = audioBuffer;
    }

    // ==========================================================
    // ğŸ’¡ [Format 2] MV2 íŒŒì„œ (15fps, MP3 Audio, 512B Header)
    // ==========================================================
    async parseMV2(data) {
        this.frames = [];
        let offset = 512; // ì²« 512ë°”ì´íŠ¸ë§Œ ê¸€ë¡œë²Œ í—¤ë”
        let mp3Chunks = [];
        let isFirstFrame = true;

        while (offset < data.length) {
            const blockSize = isFirstFrame ? 15872 : 16384;
            if (offset + blockSize > data.length) break;

            const pgt = data.slice(offset, offset + 6144);
            const ct = data.slice(offset + 6144, offset + 12288);
            const palRaw = data.slice(offset + 12288, offset + 12318); // 30 bytes
            
            const sz = data[offset + 12800]; // MP3 ì²­í¬ ì‚¬ì´ì¦ˆ ì¸ë””ì¼€ì´í„°
            const mp3Data = data.slice(offset + 12801, offset + 12801 + (sz * 32));
            
            const palette = this.extractPalette(palRaw, 15);
            this.frames.push({ pgt, ct, palette });
            mp3Chunks.push(mp3Data);

            offset += blockSize;
            isFirstFrame = false;
        }

        this.totalFrames = this.frames.length;

        // ì¡°ê°ë‚œ MP3 ë°”ì´ë„ˆë¦¬ë¥¼ í•˜ë‚˜ë¡œ í•©ì³ì„œ ë¸Œë¼ìš°ì € ë„¤ì´í‹°ë¸Œ ë””ì½”ë”ì— ìœ„ì„
        const totalMp3Length = mp3Chunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const mp3Concat = new Uint8Array(totalMp3Length);
        let writeOffset = 0;
        for (let chunk of mp3Chunks) {
            mp3Concat.set(chunk, writeOffset);
            writeOffset += chunk.length;
        }

        // Web Audio API ë¹„ë™ê¸° í•˜ë“œì›¨ì–´ MP3 ë””ì½”ë”©
        this.audioBuffer = await this.audioCtx.decodeAudioData(mp3Concat.buffer);
    }

    // MSX2 RGB333 (2Bytes) -> RGB888 (ë°°ì—´) ë³€í™˜
    extractPalette(palData, colorCount) {
        const pal = [[0,0,0]]; // Color 0ì€ íˆ¬ëª…/ê²€ì •
        for (let i = 0; i < colorCount; i++) {
            const r_b = palData[i * 2];     // 0ë²ˆ ë°”ì´íŠ¸: [R(4) | B(4)]
            const g = palData[i * 2 + 1];   // 1ë²ˆ ë°”ì´íŠ¸: [0000 | G(4)]
            
            const r8 = ((r_b >> 4) & 0x0F) * 255 / 7;
            const b8 = (r_b & 0x0F) * 255 / 7;
            const g8 = (g & 0x0F) * 255 / 7;
            
            pal.push([r8, g8, b8]);
        }
        return pal;
    }

    // ==========================================================
    // ğŸ’¡ í™”ë©´ ë Œë”ëŸ¬ (SCREEN 2 ë¹„íŠ¸ ì—°ì‚°)
    // ==========================================================
    renderFrame(frameIndex) {
        if (frameIndex >= this.totalFrames) return;
        const frame = this.frames[frameIndex];
        const imgData = this.ctx.createImageData(256, 192);
        const data = imgData.data;

        for (let y = 0; y < 192; y++) {
            for (let cx = 0; cx < 32; cx++) {
                const off = (Math.floor(y / 8) * 32 + cx) * 8 + (y % 8);
                const p_byte = frame.pgt[off];
                const c_byte = frame.ct[off];
                
                const fg = (c_byte >> 4) & 0x0F;
                const bg = c_byte & 0x0F;

                const x_start = cx * 8;
                for (let p = 0; p < 8; p++) {
                    const colorIdx = (p_byte & (1 << (7 - p))) !== 0 ? fg : bg;
                    const rgb = frame.palette[colorIdx] || [0, 0, 0];
                    
                    const pxOffset = (y * 256 + (x_start + p)) * 4;
                    data[pxOffset] = rgb[0];     // R
                    data[pxOffset + 1] = rgb[1]; // G
                    data[pxOffset + 2] = rgb[2]; // B
                    data[pxOffset + 3] = 255;    // Alpha
                }
            }
        }
        this.ctx.putImageData(imgData, 0, 0);
    }

    // ==========================================================
    // ğŸ’¡ ì˜¤ë””ì˜¤ë¥¼ ë§ˆìŠ¤í„° í´ëŸ­ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì¬ìƒ ì œì–´ (A/V Sync)
    // ==========================================================
    play() {
        if (this.isPlaying) return;
        
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();

        this.audioSource = this.audioCtx.createBufferSource();
        this.audioSource.buffer = this.audioBuffer;
        this.audioSource.connect(this.audioCtx.destination);
        
        // ì¼ì‹œì •ì§€í–ˆë˜ ì§€ì ë¶€í„° ë‹¤ì‹œ ì‹œì‘
        this.audioSource.start(0, this.pauseTime);
        this.startTime = this.audioCtx.currentTime - this.pauseTime;
        this.isPlaying = true;

        document.getElementById('btn-play').disabled = true;
        document.getElementById('btn-pause').disabled = false;

        const loop = () => {
            if (!this.isPlaying) return;
            
            // í•µì‹¬: í˜„ì¬ ì¬ìƒ ì¤‘ì¸ ì˜¤ë””ì˜¤ ì‹œê°„ì„ ê¸°ì¤€ìœ¼ë¡œ í”„ë ˆì„ ê³„ì‚° (ì‹±í¬ ì™„ë²½ ë³´ì¥)
            const currentTime = this.audioCtx.currentTime - this.startTime;
            const currentFrame = Math.floor(currentTime * this.fps);
            
            if (currentFrame < this.totalFrames) {
                this.renderFrame(currentFrame);
                this.animationId = requestAnimationFrame(loop);
            } else {
                this.pause(); // ëê¹Œì§€ ì¬ìƒë¨
            }
        };
        loop();
    }

    pause() {
        if (!this.isPlaying) return;
        this.isPlaying = false;
        
        this.audioSource.stop();
        this.pauseTime = this.audioCtx.currentTime - this.startTime;
        cancelAnimationFrame(this.animationId);

        document.getElementById('btn-play').disabled = false;
        document.getElementById('btn-pause').disabled = true;
    }
}

// UI ì´ë²¤íŠ¸ ë°”ì¸ë”©
const player = new MSXMediaDemuxer('msx-screen');

document.getElementById('file-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    try {
        await player.loadFile(file);
    } catch (err) {
        document.getElementById('status').innerText = `ì—ëŸ¬: ${err.message}`;
        console.error(err);
    }
});

document.getElementById('btn-play').addEventListener('click', () => player.play());
document.getElementById('btn-pause').addEventListener('click', () => player.pause());

</script>
</body>
</html>
